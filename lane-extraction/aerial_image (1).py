import sysimport urllibimport jsonimport mathfrom PIL import Imageimport iolevel = 23param = urllib.urlencode({"key":"ArSkGTLs-eC_9nbM84_EJ-tjISwN7rcDT0Vvw1jQhccWLoAGJYE4jX2AapF9aBKa"})def latlon2pixelxy(lat,lon,mapSize):    x=(lon+180)/360    temp=math.sin(lat*math.pi/180)    y=0.5-math.log((1+temp)/(1-temp))/(4*math.pi)    pixelx = int(x*mapSize+0.5)    pixely = int(y*mapSize+0.5)    return [pixelx, pixely]def pixelxy2tilexy(xy):    x = xy[0]    y = xy[1]    tilex=int(x/256)     tiley=int(y/256)    return [tilex, tiley]def tilexytoquad(tx,ty):	quad = ""	for i in xrange(level,0, -1):		digit='0'		mask = (1 << (i - 1)) & 0xffffffff # python int is not size-fixed				if (tx&mask) !=0:			digit = chr(ord(digit) + 1)		if (ty&mask) !=0:			digit = chr(ord(digit) + 1)			digit = chr(ord(digit) + 1)		quad += digit	return quaddef getTileQuadsInBound(tile1X, tile1Y, tile2X, tile2Y, p2level):	tiles=[]	for r in xrange(tile1Y, tile2Y+1):                row = []		for c in xrange(tile1X, tile2X+1):                        c %= p2level			row.append(tilexytoquad(c,r))		tiles.append(row)	return tiles  def isSameImage(im1, im2):    if im1.size != im2.size:        return False    for i in xrange(0, im1.height):        for j in xrange(0, im1.width):            if im1.getpixel((j, i)) != im2.getpixel((j, i)):                return False    return Truelat1 = float(90)lon1 = float(180)file = open("drive.traj","r")lines = file.readlines()count = 0pixels = open("pixel.csv","w")lastQuad = ""done = Falsetraj = open("pixel_traj.csv","w")for line in lines:    attrs = line.split(" ")    lat1 =float(attrs[0])    lon1 =float(attrs[1])    lat1= min(max(lat1,-85.05112878),85.05112878)    lon1= min(max(lon1,-180),180)    tile1xy = None    tile1 = None    done = False    while level > 0:        mapsize= 256*2**level        tile1xy = latlon2pixelxy(lat1, lon1, mapsize)        tile1 = pixelxy2tilexy(tile1xy)        testQuad = tilexytoquad(tile1[0], tile1[1])        if testQuad == lastQuad:            print "Image has been downloaded"            done = True            break        else:            lastQuad = testQuad        request = "http://h0.ortho.tiles.virtualearth.net/tiles/a%s.jpeg?g=131&%s" % (testQuad, param)        url = urllib.urlopen(request)        testImage = Image.open(io.BytesIO(url.read()))        invalidImage = Image.open('invalid.jpeg')        if isSameImage(testImage, invalidImage):            print 'forbidden level %d in the bounding area. ' % level        else:            break        level -= 1    if level == 0:        print 'no available level in the bounding area. '        exit()    if done == True:        continue    p2level = 2**level    print "finished calculation. "    count += 1    print "%d" % count    testImage.save("%d.jpeg" % count)    pixels.write("%d,%d\n" % (tile1[0]*256,tile1[1]*256))for line in lines:    attrs = line.split(" ")    lat1 =float(attrs[0])    lon1 =float(attrs[1])    tile1xy = latlon2pixelxy(lat1, lon1, mapsize)    traj.write("%d,%d\n" % (tile1xy[0],tile1xy[1]))print "finished download and stitching. "for i in xrange(1,count+1):    im = Image.open("%d.jpeg" % i)    im = im.convert("L")    im = im.point(lambda i: i>220 and 255)    im.save("%d.jpeg" % i)